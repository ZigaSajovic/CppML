# `<CppML/Pack/Concat.hpp>`

## `Concat`

```c++
template <typename Pipe = ml::ToList>
struct Concat {
  template <typename ...Ts>
  using f = /* .... */;
};
```
### `Concat<Pipe>`

`Concat<Pipe>` is a metafunction that passes to `Pipe` the type `T<Us...>`, which is generated by concatenating all templates of the parameter pack `Ts<As...>...`.  `Pipe` defaults to [`ml::ToList`](../Functional/ToList.md).

```c++
f::  T<As...>, ...., T<Ns...> ->  T<As..., ..., Ns...> <-> Pipe
```

### `Ts...`

Each input type needs to be a template class, `Ts<As...>...`.

### Example

```c++
using T0 = ml::Invoke<
                   ml::Concat<>,
                   ml::ListT<int>, ml::ListT<char, bool>>;

static_assert( std::is_same_v<
                          T0,
                          ml::ListT<int, char, bool>>);
using T1 = ml::Invoke<
                   ml::Concat<>,
                   std::tuple<int>, std::tuple<char, bool>>;

static_assert( std::is_same_v<
                          T1,
                          std::tuple<int, char, bool>>);
```
