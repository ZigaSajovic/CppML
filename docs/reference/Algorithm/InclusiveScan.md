# `<CppML/Algorithm/InclusiveScan.hpp>`

## `InclusiveScan`

```c++
template <typename F, typename Pipe = ml::ToList>
struct InclusiveScan {
  template <typename Init, typename ...Ts>
  using f = /* .... */;
};
```
### `InclusiveScan<F, Pipe>`

`InclusiveScan<F, Pipe>` is a metafunction that passes to `Pipe` a parameter pack `Us...`, which is generated by computing the prefix binary operation `F` on the parameter pack `Ts...`. `Pipe` defaults to [`ml::ToList`](../Functional/ToList.md).

```c++
f:: Ts... -> T0, F(T0, T1), F(F(T0, T1), T3), ... >-> Pipe
```

#### F
F is to be a metafunction from two types, to one.
```
f:: T, U -> V
```

### Example

We implement a metafunction, which counts how many types that are class types, have occurred up to current location, using `InclusiveScan`. See also [`ml::ProductMap`](../Functional/ProductMap.md). Note that due to how `InclusiveScan` uses the first element of `Ts...` as `Init`, we will prepend `ml::Int<0>`, and `Pipe` into [`ml::Drop`](../Pack/Drop.md)`<1>`, to obtain our result.

```c++
template <typename ...Ts>
using IsClassCumSum =
    ml::f<ml::InclusiveScan<ml::ProductMap<    // Construct binary function F:
                                ml::Identity,  // Map first element (Init in F)
                                               // by identity
                                ml::IsClass<>, // Map second element (T in F) by
                                               // IsClass
                                ml::Add<>>,    // And pipe to Add
                            ml::Drop<1>>,      // Drop the first (Init)
          ml::Int<0>, Ts...>; 
using T = IsClassCumSum<int, std::string, bool, std::string>;

static_assert(
              std::is_same_v<
                  T,
                  ml::ListT<
                    ml::Int<0>, ml::Int<1>, ml::Int<1>, ml::Int<2>>>);
```
