# `<CppML/Functional/Bind.hpp>`

#### Table of Contents

* [Par](#par)
* [Bind](#bind)

## `Par`
```c++
template <int I, typename T>
struct Par;
```

### `Par<I, T>`

`Par<I, T>` is a parameter holder for [`ml::Bind`](#bind), where `I` specifies the position of `T`, when the bound metafunction is invoked.

**NOTE**

Aliases of the form
```c++
template <typename T>
using _p0 = Par<0, T>;
```
are defined in the range `[0, 20]`.

## `Bind`

```c++
template <typename F, int ...Is, typename ...Args>
struct Bind<F, ml::Par<Is, Args>...> {
  template <typename ...Ts>
  using f = /* .... */;
};
```
### `Bind<F, Par<Is, Args>...>`

`Bind<F, Par<Is, Args>...>` is a metafunction, that is a partial evaluation of `F`
, with `Args...` bound to  positions `Is...`. When invoked on `Ts...`, it is as if `F` was invoked on `Us...`, which was generated by inserting each element of `Args...` in `Is...` position in `Ts...`.

```c++
f:: Ts... -> F(Us...)
```

**NOTE**

[`ml::Par<Is, Args>`](#par)`...` must appear in ascending sorted order (by `int ...Is`).


### Example

To make the example explicit, we bind [`ml::Int`](../Vocabulary/Value.md) in their corresponding positions for [`ml::ToList`](./ToList.md), and invoke it on the rest.

```c++

using Bound = ml::Bind<
                ml::ToList,
                ml::_p1<ml::Int<1>>,
                ml::_p3<ml::Int<3>>>;

using T = ml::f<
              Bound,
              ml::Int<0>, ml::Int<2>, ml::Int<4>>; 

static_assert(
        std::is_same_v<
                T0,
                ml::ListT<
                  ml::Int<0>, ml::Int<1>, ml::Int<2>, ml::Int<3>, ml::Int<4>>>);
```
