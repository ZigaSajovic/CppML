# `<CppML/Functional/Product.hpp>`

## `Product`

```c++
template <typename ...Fs, typename Pipe>
struct Product {
  template <typename ...Ts>
  using f = /* .... */;
};
```
### `Product<Fs..., Pipe>`

`Product<Fs..., Pipe>` is a metafunction that passes to `Pipe` the parameter pack `Us...`, which is generated by invoking each `F` in the parameter pack `Fs...` on the entire parameter pack `Ts...`.

```c++
f:: Ts... -> Fs(Ts...)... >-> Pipe
```

#### `Args...`

The parameter pack of the `Product<Args...>` will be treated as `Pipe`, and must always be provided (there is no default).

### Example

The [`ml::Partition`](../Algorithm/Partition.md) can be implemented a [`Product`](./Product.md) of [`ml::Filter`](../Algorithm/Filter.md) and [`ml::RemoveIf`](../Algorithm/RemoveIf.md), that `Pipe`s to [`ml::ToList`](./ToList.md).

```c++
template <typename Predicate>
using Partition = ml::Product<
                      ml::Filter<Predicate>,
                      ml::RemoveIf<Predicate>,
                      ml::ToList>;
using T = ml::f<
              Partition<ml::IsClass<>>,
              int, std::string, char>;
static_assert(
      std::is_same_v<
            T,
            ml::ListT<
                ml::ListT<std::string>,
                ml::ListT<int, char>>>);
```
